## Part 1. Инструмент ipcalc

### 1.1 Сети и маски
**1) адрес сети `192.167.38.54/13 `**

Команда - `ipcalc 192.167.38.54/13 `

![ipcalc -b 192.167.38.54/13](screenshots/1/1.png)

192.267.38.54

**2) перевод маски `255.255.255.0` в префиксную и двоичную запись, `/15` в обычную и двоичную, `11111111.11111111.11111111.11110000` в обычную и префиксную**
Команда - `ipcalc 255.255.255.0`

![ipcalc 255.255.255.0](screenshots/1/2.png)

префиксная форма записи */24
двоичная форма записи *11111111.11111111.11111111.00000000
Команда - `ipcalc /15`

![](screenshots/1/Снимок%20экрана%202023-05-08%20в%2015.50.35.png)
Обычная запись - `255.254.0.0`. Двоичная запись - `11111111.11111110.00000000.00000000`

Посчитаем количество ненулевых бит в 11111111.11111111.11111111.11110000 и получим - 28.
Команда - `ipcalc 192.167.38.54/28`

![Part_1.1.2.3.jpg](screenshots/1/Снимок%20экрана%202023-05-08%20в%2015.53.29.png)

Обычная запись - `255.255.255.240`. Префиксная запись - `/28`.

**3) минимальный и максимальный хост в сети `12.167.38.4` при масках: `/8, 11111111.11111111.00000000.00000000, 255.255.254.0 и /4`**

Воспользуемся командами:
`ipcalc 12.167.38.4/8`
`ipcalc 12.167.38.4/4`
`ipcalc 12.167.38.4/16`
`ipcalc 12.167.38.4/23`

![](screenshots/1/3.png)

Минимальный хост - `12.0.0.1`. Максимальный хост - `12.255.255.254`.

Минимальный хост - `0.0.0.1`. Максимальный хост - `15.255.255.254`.

Минимальный хост - `12.167.0.1`. Максимальный хост - `12.167.255.254`. 

Минимальный хост - `12.167.38.1`. Максимальный хост - `12.167.39.254`.

### 1.2. Localhost  
**Определить и записать в отчёт, можно ли обратиться к приложению, работающему на localhost, со следующими IP: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1**

Пишем в гугле "localhost" и в первой ссылке на википедию видим, что для localhost зарезервирован диапазон ip адресов от 127.0.0.1 до 127.255.255.254 включительно. Из этого можем сделать вывод, что мы сможем обратиться к приложениям, работающим со следующими ip: `127.0.0.2`, `127.1.0.1`.  

Воспользуемся командами:
`ipcalc 194.34.23.100`
`ipcalc 127.0.0.2`
`ipcalc 127.1.0.1`
`ipcalc 128.0.0.1`

![](screenshots/1/4.png)

Интерфейс loopback отсутствует в строке "Hosts/Net", следовательно данный адрес нам не подходит.
Loopback присутствует, следовательно адрес нам подходит.
Loopback тоже есть, следовательно адрес нам подходит.
Loopback нет, адрес не подходит. 

### 1.3. Диапазоны и сегменты сетей  

**1) Какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1**

Выведем информацию обо всех ip адресах с помощью команды `ipcalc <ip адрес>`

![](screenshots/1/5.png)
![](screenshots/1/6.png)
![](screenshots/1/7.png)

Нас интересует строка "Hosts/Net" и конкретно надпись "Private Internet", наличие которой говорит о том, что ip адрес принадлежит частной сети. 

>Адреса `10.0.0.45`, `192.168.4.2`, `172.20.250.4`, `172.16.255.255`, `10.10.10.10` можно использовать только в качестве частных.  

>Адреса `134.43.0.2`, `172.0.2.1`, `192.172.0.1`, `172.68.0.2`, `192.169.168.1` можно использовать в качестве публичных.

## Part 2. Статическая маршрутизация между двумя машинами

### 2.0 Поднятие двух виртуальных машин и просмотр интерфейсов

**1) Поднять две виртуальные машины**

![](screenshots/2/1.png)

**2) С помощью команды ip a посмотреть существующие сетевые интерфейсы**

![](screenshots/2/2.png)
![](screenshots/2/3.png)

**3) Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - 192.168.100.10, маска /16, ws2 - 172.24.116.8, маска /12**

![](screenshots/2/4-5.png)

### 2.1 Добавление статического маршрута вручную

Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида ip r add
Пропинговать соединение между машинами

![](screenshots/2/6-7-8-9.png)

### 2.2. Добавление статического маршрута с сохранением

**1) Перезапустить машины**

![](screenshots/2/10.png)

**2) Добавить статический маршрут от одной машины до другой с помощью файла etc/netplan/00-installer-config.yaml**

![](screenshots/2/11.png)
![](screenshots/2/12.png)

**3) Пропинговать соединение между машинами**

![](screenshots/2/13.png)
![](screenshots/2/14.png)

## Part 3. Утилита iperf3

**3.1. Скорость соединения**

Перевести и записать в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps  
1) 8 Mbps = 1 MB/s
2) 100 MB/s = 819200 Kbps 
3) 1 Gbps = 1024 Mbps

**3.2. Утилита iperf3**
**Измерить скорость соединения между ws1 и ws2**

![](screenshots/3/1.png)

ws2 выступает в роли сервера. Запуск командой `iperf3 -s`
ws1 выступает в роли клиента. Запуск командой `iperf3 -c 172.24.116.8`

## Part 4. Сетевой экран

**4.1. Утилита iptables**

>Ключи iptables:
>-A: добавить правило в конец цепочки
>-C: проверить существование правила в цепочке
>-D: удалить правило из цепочки
>-E: изменить имя пользовательской цепочки
>-F: очистить цепочку от всех правил
>-I: вставить правило в начало цепочки
>-L: вывести список правил в цепочке
>-N: создать новую пользовательскую цепочку
>-X: удалить пользовательскую цепочку
>-Z: сбросить счетчики пакетов и байтов для всех правил в цепочке
>-P: установить политику по умолчанию для цепочки
>-p: указать протокол (tcp, udp, icmp и т.д.)
>-s: указать исходный IP-адрес
>-d: указать целевой IP-адрес
>--sport: указать исходный порт
>--dport: указать целевой порт
>-j: указать целевое действие (ACCEPT, DROP, REJECT и т.д.)
>-i: указать сетевой интерфейс входящего трафика
>-o: указать сетевой интерфейс исходящего трафика
>-m: указать модуль расширения (например, mod_tcpudp для фильтрации по портам TCP и UDP)
>-v: выводить детальную информацию о правилах
>-h: вывести справку о команде

Посмотреть состояние iptables:
`sudo iptables -L`

Посмотреть состояние таблицы:
`sudo iptables -t <имя таблицы> -L`

Нужно добавить в файл подряд следующие правила:
1) на ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5)
2) на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5)
3) открыть на машинах доступ для порта 22 (ssh) и порта 80 (http)
4) запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT)
5) разрешить echo reply (машина должна "пинговаться")

![](screenshots/4/1.png)

Запустить файлы на обеих машинах командами `chmod +x /etc/firewall.sh` и `/etc/firewall.sh`
![](screenshots/4/2.png)

Машина ws1 не сможет отправлять echo-request пакеты, но сможет принимать их, тогда как машина ws2 сможет отправлять эти пакеты, но не сможет принимать их.

В обоих случаях отрабатывается верхнее правило (DROP для ws1 и ACCEPT для ws2).

Если пакет соответствует только верхнему правилу в цепочке, то будет выполнено только это правило. Однако, если пакет соответствует нескольким правилам в цепочке, то будет выполнено только первое правило, которое соответствует пакету.

Если нужно, чтобы пакет, соответствующий более чем одному правилу, был обработан несколькими правилами, можно использовать цепочки пользовательского определения (user-defined chains) в iptables, где каждое правило может перенаправлять пакеты в другие цепочки.

**4.2. Утилита nmap**

Командой `ping` найти машину, которая не "пингуется" 

![](screenshots/4/3.png)

Видим что с `ws1` в `ws2` не передаются пакеты

утилитой nmap показать, что хост машины запущен

![](screenshots/4/4.png)

Проверка: `Host is up`

И опять проверка на пинг машины без утери пакетов
![](screenshots/4/5.png)

Сохраняем дампы образов виртуальных машин
<!-- ![](screenshots/4/Снимок%20экрана%202023-05-04%20в%2019.34.02.png) -->

## Part 5. Статическая маршрутизация сети

Поднять пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2)) как на фото

![](screenshots/5/part5_network.png)

![](screenshots/5/1.png)

**5.1. Настройка адресов машин**

Настроить конфигурации машин в `etc/netplan/00-installer-config.yaml` согласно сети на рисунке.

![](screenshots/5/2.png)
![](screenshots/5/3.png)
![](screenshots/5/4.png)
![](screenshots/5/5.png)
![](screenshots/5/6.png)

Перезапустить сервис сети. Если ошибок нет, то командой `ip -4 a` проверить, что адрес машины задан верно. Также пропинговать `ws22` с `ws21`. Аналогично пропинговать `r1` с `ws11`.

![](screenshots/5/7.png)
![](screenshots/5/8.png)
![](screenshots/5/12.png)
![](screenshots/5/13.png)

**5.2. Включение переадресации IP-адресов.**

`sysctl -w net.ipv4.ip_forward=1`
При таком подходе переадресация не будет работать после перезагрузки системы.

![](screenshots/5/14.png)

Откройте файл `/etc/sysctl.conf` и добавьте в него следующую строку:
`net.ipv4.ip_forward = 1`
При использовании этого подхода, IP-переадресация включена на постоянной основе.

![](screenshots/5/15.png)
![](screenshots/5/16.png)

**5.3. Установка маршрута по-умолчанию**

Настраиваем маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавляем ` gateway4: ip роутера ` в файле конфигураций ` etc/netplan/00-installer-config.yaml `

Командой - `sudo vim /etc/netplan/00-installer-config.yaml`

![](screenshots/5/17.png)
![](screenshots/5/18.png)
![](screenshots/5/19.png)

Вносим изменения командой - `sudo netplan apply`

Вызовем `ip r`, чтобы показать, что  маршрут добавился в таблицу маршрутизации

![](screenshots/5/20.png)

Пропингуем с ` ws11 ` роутер ` r2 `, пинг не пройдёт, т.к. роутер "не знает" куда вернуть ответ, при этом передача пакетов с машины осуществляется. 

Чтобы посмотреть какие девайсы можно прослушать

Командой - `tcpdump -D ` 

Запускаем на ` r2 ` утилиту ` tcpdump `, она позволяет прослушать порты и вывести на экран информацию с каких IP адресов приходят пакеты. В данном случае слушаем интерфейс ` enp0s8 `

Командой - `tcpdump -tn -i enp0s8 `

Сначала на экране r2 будет пусто, идёт ожидание входящих пакетов

Запускаем `ping` на ` ws11 ` 

Командой - `ping -c 5 10.100.0.12`

![](screenshots/5/21.png)

На экране должно ` r2 ` должно появиться

![](screenshots/5/22.png)

**5.4. Добавление статических маршрутов**

Добавить в роутеры `r1` и `r2` статические маршруты в файле конфигураций. Пример для `r1` маршрута в сетку `10.20.0.0/26`

Вызвать `ip r` и показать таблицы с маршрутами на обоих роутерах. Пример таблицы на `r1`

![](screenshots/5/23.png)
![](screenshots/5/24.png)

Запустить команды на `ws11`

`ip r list 10.10.0.0/18 `

`ip r list 0.0.0.0/0 `

![ip r list ws11](screenshots/5/25.png)

Для адреса `10.10.0.0/18` был выбран маршрут, отличный от `0.0.0.0/0` (он попадает под маршрут по-умолчанию), т.к. машина ` ws11 ` соединена с сетью `10.10.0.0/18` по своему IP-адресу `10.10.0.2`, для других адресов используется маршрут по умолчанию, который указан в файле `10.10.0.1`.

**5.5. Построение списка маршрутизаторов**

Для установки утилиты на ` ws11 ` используем команду 

`sudo apt install traceroute `

Запустим на `r1` команду дампа 

`tcpdump -tnv -i enp0s8`

![tcpdump r1](screenshots/5/26.png)

При помощи утилиты `traceroute` построим список маршрутизаторов на пути от `ws11` до `ws21`. 

![traceroute ws11 to ws21](screenshots/5/27.png)

**5.6. Использование протокола ICMP при маршрутизации**

Запустим на `r1` перехват сетевого трафика, проходящего через `enp0s8` с помощью команды

`sudo tcpdump -n -i enp0s8 icmp`

Пропингуем ws11 c командой

`ping -c 1 10.30.0.111`

![tcpdump r1](screenshots/5/28.png)

Сохраняем дампы образов виртуальных машин

## 6.1 Настройка службы DHCP на r2

Если утилита `isc-dhcp-server` ещё не установлена, то файла `/etc/dhcp/dhcpd.conf` ещё не существует в нужном виде. Соотвтетственно для работы с протоколом `DHCP` сначала надо установить эту утилиту

`sudo apt-get install isc-dhcp-server`

Теперь для `r2` можем настроить в файле `/etc/dhcp/dhcpd.conf` конфигурацию службы  `DHCP`

указываем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети.

Открываем файл `/etc/dhcp/dhcpd.conf` для редактирования

`sudo vim /etc/dhcp/dhcpd.conf`

Так выглядит только что открытый файл `dhcpd.conf`

![](screenshots/6/1.png)
![](screenshots/6/2.png)

Вносим изменения

![](screenshots/6/three.png)

в файле `/etc/resolv.conf`(содержит адреса серверов имен, к которым имеет доступ данная система) прописываем `nameserver 8.8.8.8`

`sudo vim /etc/resolv.conf`

![settings for resolv.conf 1](screenshots/6/4.png)
![settings for resolv.conf 2](screenshots/6/5.png)

Перезагрузим службу `DHCP`

`systemctl restart isc-dhcp-server`

![restart dhcp r2](screenshots/6/6.png)

Можно проверить статус службы

`sudo systemctl status isc-dhcp-server`

![status dhcp](screenshots/6/7.png)

Изменим настройки машин `ws21` и `ws22` в файле конфигурации, чтобы сделать протокол `DHCP` активным. На каждой машине введём

`sudo vim /etc/netplan/00-installer-config.yaml`

`sudo netplan apply`

![netplan ws21](screenshots/6/8.png)
![netplan ws22](screenshots/6/9.png)

Перезагружаем виртуальную машину `ws21`

`sudo systemctl reboot`

Проверяем присвоенный устройствам адрес

![after reboot ws21 ip a](screenshots/6/10.png)
![after reboot ws22 ip a](screenshots/6/11.png)


Проверим соединение машины `ws22` с `ws21`

![ping ws22 with ws21](screenshots/6/12.png)

## 6.2 Указать MAC-адреса 

Чтобы указать MAC-адрес у `ws11`, в файл `etc/netplan/00-installer-config.yaml` надо добавить строки: `macaddress: 10:10:10:10:10:BA`, `dhcp4: true`

`sudo vim /etc/netplan/00-installer-config.yaml`

`sudo netplan apply`

![netplan ws11](screenshots/6/13.png)

`sudo shutdown -h now`ip

Заходим в менеджер виртуальных машин VirtualBox и там настраиваем `ws11` MAC-адрес

![extra settings for ws11](screenshots/6/14.png)

Для `r1` настроим аналогично `r2`, но выдачу адресов сделаем с жесткой привязкой к MAC-адресу (`ws11`).

`sudo apt-get install isc-dhcp-server`

`sudo vim /etc/dhcp/dhcpd.conf`

![settings for dhcp r1](screenshots/6/15.png)

`sudo vim /etc/resolv.conf`

![settings for resolv.conf](screenshots/6/16.png)

`systemctl restart isc-dhcp-server`

![restart_dhcp_r1](screenshots/6/17.png)

`sudo systemctl status isc-dhcp-server`

![status dhcp](screenshots/6/18.png)

Проводим аналогичные тесты - смотрим какой адрес назначен машине `ws11`

`ip a`

![ip_a_ws22](screenshots/6/19.png)

Пропингуем соединение

`ping -c 5 10.10.0.4`

![ping_ws22_ws11](screenshots/6/20.png)

**6.3 Обновление ip адреса с помощью команды `sudo dhclient`.**

Проверяем IP до обновления

![ip a ws21 before](screenshots/6/21.png)

Запросим с `ws21` обновление ip адреса с помощью команды

`sudo dhclient -v`

`-v` - будет выведена дополнительная информация.

![dhclient -v ws21](screenshots/6/22.png)

`ip a`

![ip a ws21 after dhclient -v](screenshots/6/23.png)

Выполним команду для удаления старого IP адреса

`sudo dhclient -r`

`-r` - явно освобождает текущую аренду ip адреса.

![dhclient -r ws21](screenshots/6/24.png)

Чтобы обновить или освободить IP-адрес для конкретного интерфейса, например, eth0, необходимо ввести:

`sudo dhclient -r eth0`

`sudo dhclient eth0`

Проверим IP адреса

`ip a`

![ip a ws21 after](screenshots/6/25.png)

В части 6 были использованы следующие опции `DHCP` протокола:
`option routers *ip-address [, ip-address...];*` - адреса шлюзов для клиентской сети. Маршрутизаторы должны быть перечислены в порядке предпочтительности.
`option domain-name-servers *ip-address [, ip-address...];*` - Список DNS серверов  доступных клиенту. Сервера должны быть перечислены в порядке предпочтительности.

Сохраняем дампы образов виртуальных машин

## Part 7. NAT

Для работы с сервером `apache2`, установим его на машины ` r1 `, ` r2 ` и ` ws22 `. Возможно ` apache2 ` не будет устанавливаться, тогда возможно поможет обновление системы (см. ниже).

`sudo apt install apache2`

Обновление системы

`sudo apt update`

`sudo apt upgrade -y`
`-y` - при запросе сразу согласиться с установкой.

## 7.1 Делаем сервер Apache2 общедоступным.

В файле `/etc/apache2/ports.conf` на `ws22` и `r2` меняем строку `Listen 80` на `Listen 0.0.0.0:80`.

`sudo vim /etc/apache2/ports.conf `

![change apache2 ports.conf r1](screenshots/7/1.png)
![change apache2 ports.conf ws22](screenshots/7/2.png)

Запустить веб-сервер **Apache** командой на ` ws22 ` и ` r1 `

`service apache2 start ` 

![apache2 start r1](screenshots/7/3.png)
![apache2 start ws22](screenshots/7/4.png)

## 7.2 Создаем фаервол на r2 (как в части 4) Следующие правила:

1) Удаление правил в таблице filter - ` iptables -F `
2) Удаление правил в таблице "NAT" - ` iptables -F -t nat `
3) Отбрасывать все маршрутизируемые пакеты - ` iptables --policy FORWARD DROP `

![write firewall r2](screenshots/7/5.png)

Запустим файлы на командой

`sudo chmod +x /etc/firewall.sh`

`sudo bash /etc/firewall.sh `

![start firewall r2](screenshots/7/6.png)

 При запуске файла ` firewall.sh ` с этими правилами, ` ws22 ` не должна "пинговаться" с ` r1 `.

Проверяем соединение между ` r1 ` и ` ws22 `

` ping -c 5 10.20.0.20 `

![ping r1 ws22](screenshots/7/7.png)

Проверяем соединение между ` ws22 ` и ` r1 `

` ping -c 5 10.100.0.11 `

![ping ws22 r1](screenshots/7/8.png)

1) Разрешить маршрутизацию всех пакетов протокола ICMP, для этого прописываем правило для протокола *icmp* и цепочки *FORWARD*

`sudo vim /etc/firewall.sh`

![iptables write r2](screenshots/7/9.png)
![iptables run.sh r2](screenshots/7/10.png)

Теперь при запуске файла ` firewall.sh ` с этими правилами, ` ws22 ` должна "пинговаться" с ` r1 `

Проверяем соединение между ` r1 ` и ` ws22 `
Проверяем соединение между ` ws22 ` и ` r1 `

`ping -c 5 10.100.0.11`
`ping -c 5 10.20.0.20 `

![ping r1 ws22](screenshots/7/11.png)

Добавляем в файл ещё два правила:

1) Включаем `SNAT`, а именно маскирование всех локальных ip из локальной сети, находящейся за `r2` (по обозначениям из Части 5 - сеть 10.20.0.0)

2) Включаем `DNAT` на 8080 порт машины `r2` и добавим к веб-серверу Apache, запущенному на `ws22`, доступ извне сети

` sudo vim /etc/firewall.sh `

![iptables SNAT DNAT](screenshots/7/12.png)

> Значения использованных опций:
> - ` t ` - указывает на используемую таблицу;
> - ` p ` - указывает протокол, такие как tcp, udp, udplite и другие, поддерживаемые системой, ознакомиться со списком можно в файле ` /etc/protocols `;
> - ` m ` - подключает указанный модуль;
> - ` s ` - указывает адрес источника пакета, в качестве значения можно указать как один IP-адрес, так и диапазон;
> - ` i ` - задает входящий сетевой интерфейс;
> - ` o ` - указывает исходящий сетевой интерфейс;
> - ` --dport ` - порт получателя пакета;
> - ` DNAT ` — подменяет адрес получателя в заголовке IP-пакета, основное применение — предоставление доступа к сервисам снаружи, находящимся внутри сети;
> - ` SNAT ` — служит для преобразования сетевых адресов, применимо, когда за сервером находятся машины, которым необходимо предоставить доступ в Интернет, при этом от провайдера имеется статический IP-адрес.

#### SNAT и DNAT 

Запускаем файл также, как в Части 4 (перед тестированием отключим сетевой интерфейс `NAT` (его наличие можно проверить командой ` ip a `) в VirtualBox, если он включен)

![iptables sh run](screenshots/7/13.png)

Проверяем соединение по TCP для SNAT, для этого с ` ws22 ` подключаемся к серверу Apache на ` r1 ` командой ` telnet [адрес] [порт] `

` telnet 10.100.0.11 80 `

![telnet ws22](screenshots/7/14.png)

Проверить подмену IP-адреса можно с помощью команды ` tcpdump ` - пингуем с машины ` ws22 ` роутер ` r1 `, в выводе ` tcpdump ` будет отображаться с какого адреса идет запрос - IP-адрес ` r2 ` 

![tcpdump r1](screenshots/7/15.png)
![ping ws22 r1](screenshots/7/16.png)

Проверяем соединение по TCP для DNAT, для этого с ` r1 ` подключаемся к серверу Apache на ` ws22 ` (обращаться по адресу ` r2 ` и порту 8080)

` telnet 10.100.0.12 8080 `

![telnet_r1](screenshots/7/17.png)

При этой проверке следует отключить на ` ws22 ` автоматическую выдачу ip ` enp0s3 `

` sudo tcpdump -i enp0s8 `

![tcpdump-r1](screenshots/7/18.png)

Сохраняем дампы образов виртуальных машин